---
title: "Introduction to GenomicBreaks"
author: 
 - "Charlotte West"
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Introduction to GenomicBreaks}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE)
knitr::opts_knit$set(verbose = TRUE)
```

# Introduction

The _GenomicBreaks_ R package contains tools for visualising and analysing
characteristics associated with _breakpoints_ between pairs of _genomes_.

## Load pacakges

Core packages that provide functions we use a lot.

```{r loadlib, echo=T, results='hide'}
suppressPackageStartupMessages({
  library('GenomicBreaks')
  library('BSgenome')
  library('GenomicFeatures')
  library('GenomicRanges')
  library('ggplot2')
})
```

We will use yeast data as an example, so let's load the `Scerevisiae` BSgenome
package.

```{r load_BSgenome_packages}
library("BSgenome.Scerevisiae.UCSC.sacCer3")
```

## Example data

This package contains an example data file representing the alignment of the
_Saccharomyces paradoxus_ genome version `ASM207905v1` to the `SacCer3` reference genome of
_S. cerevisiae_.  An alignment file was produced with a Nextflow
[pairwise alignment pipeline](https://github.com/oist/plessy_pairwiseGenomeComparison)
and converted to [GFF3](https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md)
format with the `maf-convert gff -J 1000000` command of the
[LAST](https://gitlab.com/mcfrith/last/-/blob/main/doc/maf-convert.rst) package.

```{r locate_example_data}
exdata <- system.file("extdata/SacCer3__SacPar.gff3.gz", package = "GenomicBreaks")
rtracklayer::import(exdata)
```

# GBreaks objects

Pairwise genome alignments are loaded in `GBreaks()` objects that wrap the
`GRanges` class.  By convention, we write that the _query_ genome (the one that
was provided as a FASTA file) is aligned to the _target_ genome (the one that
was indexed by the aligner).  The _target_ genome (on the left) is the main part
of the object, and the _query_ genome information (right) is contained in the
metadata columns (`mcols`) of the structure.  Information on contig or scaffold
length is optionaly loaded from `BSgenome` objects, from which `seqinfo` data
is extracted and passed to the `GRanges`.  By convention, strand information
of the alignment is held by the _target_ `GRanges`, and the _query_ `GRanges`
are strandless.  The objects are sorted by `seqname` first.

```{r GRanges object}
gb <- load_genomic_breaks(exdata, Scerevisiae)
gb
gb$query
```

## Maniuplation of GBreaks objects with plyranges

With the _plyranges_ package it is easy to manipulate `GBreaks` objects, in
particular when filtering on features of the _query_ genome.

```{r plyranges_example}
# Subset for chrI on the target genome.
gb |> plyranges::filter(seqnames == "chrI")

# Subset for NC_047487.1 on the query genome
gb |> plyranges::filter(seqnames(query) == "NC_047487.1")

# Add or modify columns on the fly
gb |> plyranges::mutate("Width" = width) |> head(3)
gb |> plyranges::mutate("score" = width) |> head(3)

# Etc…
```

See the [vignette of _plyranges_](https://bioconductor.org/packages/release/bioc/vignettes/plyranges/inst/doc/an-introduction.html) for more details.

## Breakpoints and alignment stops

Let us define an **alignment stop** to be a position defined in either the
_target_ or _query_ genome, where an alignment begins or ends.  Looking at the
first line in the `gb` object above, `ChrI` positions 5860 and 10010 of the
_target_ would be defined as alignment stops.  Correspondingly, we have
positions 8723 and 12176 in `NC_047487.1` of the _query_ genome as alignment
stops. 

The function `get_bps()` takes in a `GBreaks` pairwise alignment or a simple
`GRanges` object, and produces a `GRanges` object of it's associated alignment
stops.  It has `direction`, `stranded` and `sorted` options to refind its
output. 

```{r get bps}
get_bps(gb) |> head(3)
get_bps(gb, direction = "left") |> head(3)
get_bps(gb,                      stranded = TRUE) |> head(3)
get_bps(gb,                      stranded = TRUE, sorted = FALSE) |> head(3)
get_bps(gb, direction = "right", stranded = TRUE) |> head(3)
get_bps(gb$query, sorted = FALSE) |> head(3)
get_bps(gb$query) |> head(3)
```

Now, let us define a **genomic breakpoint** (or simply breakpoint) to be a
genomic structural mutation, arising from breakage and repair of the chromosome.
Such structural events include insertion, deletion, inversion and translocation,
and often arise during recombination. 

This package seeks to determine, of the group of alignment stops, which are
likely genomic breakpoints and analyse them.  Thus, filtering out alignment
stops that are a result of bioinformatic errors.

## Arms

If the positions of the centromeres are known, an annotation file can be
crafted to indicate the coordinates of the short and long arms, and the
function `flagLongShort()` can be used to transfer this annotation to the
`GBreaks` object.

```{r}
annot <- GRanges(c("chrI:1-151465", "chrI:151582-230218"))
annot$Type <- c("short", "long")
flagLongShort(gb, annot)
```

## Measures of distance

### Synteny index

Ad-hoc index measuring to what extent a scaffold of the _target_ genome is
mostly aligned to a single scaffold in the _query_ genome.   See
`?synteny_index` for details.  One limitation to the use of this
index is that it requires that at least the _query_ genome is a complete
chromosome assembly.

```{r}
synteny_index(gb)
synteny_index(swap(gb))
```

### Correlation

Ad-hoc index measuring the correlation of the coordinates of the syntenic
alignments in scaffolds of a _target_ genome and their best match in the
_query_ genome.  See `?correlation_index` for details.  This
index is more robust to the presence of uncollapsed haplotypes in the _query_
genome.

```{r}
correlation_index(gb)
correlation_index(swap(gb))
```

### Gene Order Conservation

The `GOC()` function calcluates the Gene Order Conservation number defined by
Rocha (2003, <https://doi.org/10.1016/j.tig.2003.09.011>) as “_the average
number of orthologues for which the consecutive orthologue co-occurs close by in
the other genome. It varies between 0 (no co-occurrence) and 1 (complete gene
order conservation)_”.

_Note that calculating GOC on whole-genome alignments is not expected
to produce meaningful results, and the example below is just to show that the
computation is possible.  This function is more useful when comparing the
position of orthologues, represented in a `GBreaks` object._

```{r}
GOC(gb)
GOC(swap(gb))
```

## Visualising alignments

We can use the function `scaf_align_plot` to see the alignment of query
scaffolds/chromosomes onto a specific target scaffold/chromosome of interest.

```{r echo=T, message=F, warning=F}
scaf_align_plot(gb, scaf = "chrI")
```

Here we have plotted the alignments on the Okinawa genome (y-axis) onto the Osaka genome, scaffold 2 (x-axis). The coverage of the alignment is the bar along the top. 

We can plot alignments for two of the target scaffolds side-by-side, using `align_scaf_plot-2`. This can be used in aid of superscaffolding. 

```{r echo=T, message=F, warning=F}
align_scaf_plot_2(gb, scaf = c("chrI","chrII"))
```

As you can see, scaffold 2 of the query genome aligns to the majority of both target scaffolds. This could be used as evidence to support the superscaffolding of these two scaffolds - in an effort toward chromosomal assembly. 

## Coalescing alignments

Large syntenic regions can often appear cluttered with alignment breaks,
spanning just a few basepairs.  They are either an artefact (for instance in
case of incomplete purge of haplotypes) and or true breakpoint.  The algorithm
in `coalesce_contigs` is used to produce a new GRanges object with fewer
alignment breaks by coalescing alignments separated by short (user specified)
distances.  This distance need be agreeable in both the target and query genome
in order for the coalscion to happen. 

For example, coalescing gaps of less than 500 basepairs in the `gb` alignment:

```{r coalescing algorithm}
coa <- coalesce_contigs(gb)
length(gb)
length(coa)
```

The resulting `GBreaks` object has far fewer alignments and therefore far fewer
alignment stops. The algorithm is an initial step in alignment stop filtering,
with the goal of a reduced number of alignment stops that have a high
probability of being breakpoints.

## Genome plots with genoPlotR

To visualise synteny it is clearer to plot from the coalseced objects.

```{r test_genoPlotR}
plotApairOfChrs(gb,  "chrI")
plotApairOfChrs(coa, "chrI")
```

## “Oxford” dot plots

The function `makeOxfordPlots()` outputs “Oxford” macrosynteny plots in which
all the sequence levels are merged.

```{r oxford_plots}
makeOxfordPlots(gb)
```

The plots are `ggplot2` objects that can be further customised.  Also, when
there is only one sequence levels in the _target_ or _query_ genomes, their
name is displayed, and addition of numeric scales show meaningful coordinates.

```{r custom_oxford_plots}
makeOxfordPlots(gb |> plyranges::filter(seqnames        == "chrI",
                                        seqnames(query) == "NC_047487.1")) +
  scale_x_continuous() + scale_y_continuous() +
  theme_bw() +
  theme(legend.position="none") +
  ggtitle("sacCer3 vs sacPar “Oxford” plot")
```

## Trivial translocations

### Definitions

Remember that we are working with one-to-one alignments.  Therefore deletions,
insertions and as a consequence copy number variations, are not in the aligned
regions.  Nevertheless, we can detect translocations from one chromosomal
region to another.  We define them by alignment pairs that interrupt the
colinearity between two other pairs, and that are not inversions.

### Representation

The translocation below:

```
┌──────────────┬──────────────┬──────────────┐
│ chrA:101-200 │ chrA:201-300 │ chrA:301-400 │ (Target genome)
└──────────────┴──────────────┴──────────────┘
      +               +             +         (Alignment direction)
┌──────────────┬──────────────┬──────────────┐
│ chrB:101-200 │ chrC:201-300 │ chrB:301-400 │ (Query genome)
└──────────────┴──────────────┴──────────────┘
```

Is represented as:

```{r ideal_insertions}
exampleTranslocation
plotApairOfChrs(exampleTranslocation)
```

See `vignette("StructuralVariants", package = "GenomicBreaks")` for other
examples of translocations.

Note also that *without an outgroup it is not possible to know in which genome
the move happened*.

### Detection

```{r detect_trivial_insertions}
flagTranslocations(exampleTranslocation)
showTranslocations(flagTranslocations(coa))
plotApairOfChrs(coa, chrT = "chrI", xlim = gb2xlim(coa[2:4]))
```

## Trivial inversions

See `vignette("StructuralVariants", package = "GenomicBreaks")` for definitions.

### Number of trivial inversions

More inversions are found after coalescing colinear blocks because of situations
where `+ - +` was `+ - - +` before collapsing. 

```{r detect_trivial_invertions}
flagInversions(coa)
showInversions(flagInversions(coa))
showInversions(flagInversions(coa)) |> plyranges::slice(1:3)   |> plotApairOfChrs()
showInversions(flagInversions(coa)) |> plyranges::slice(4:9)   |> plotApairOfChrs()
showInversions(flagInversions(coa)) |> plyranges::slice(10:12) |> plotApairOfChrs()
```
