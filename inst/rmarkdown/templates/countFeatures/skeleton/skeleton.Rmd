---
title: "Count features"
author: "Charles Plessy"
date: "02/07/2023"
output: 
  html_document: 
    keep_md: yes
params:
  alnFile: "/absolute/path/to/your/file"
  matchType: "match_part or match depending on GFF file format"
  prefix: "PrefixForOutputFileNames"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(progress = TRUE, verbose = TRUE, root.dir = system2("pwd", stdout = TRUE))
```

```{r load_libraries}
library("GenomicBreaks") |> suppressPackageStartupMessages()
library("ggplot2")       |> suppressPackageStartupMessages()
```

How to use this Rmarkdown template:

It is essential to set `R_LIBS_USER` to an empty value, otherwise `R` will
attempt to load packages from the user's library, which were compiled in a
different environment than the GenomicBreaks Singularity image.

Example command

```
R_LIBS_USER='' R -e 'rmarkdown::render("thisTemplate.Rmd", output_file = "./outFile.html", params = list(alnFile = "/path/do/dir/with/alignment/files"))'
```

Load data
---------

```{r load_data}
# Display parameters
params

# Load the alignment in a GBreaks object
gb <-load_genomic_breaks(params$alnFile, type = params$matchType)
```

Coalesce contigs
----------------

```{r coalesce_contigs}
coa <- coalesce_contigs(gb)
makeOxfordPlots(coa) + ggtitle(params$alnFile)
```

### Extract information

We divide the genome into four categories: _isolated alignments_, _breakpoint
regions_, _colinear alignments_ and _bridge regions_.

_Colinear alignments_ are defined by the colinearity relationship computed
in `?flagColinearAlignments`.  _Bridge regions_ separate alignments that are
colinear to each other.  _Isolated alignments_ have no colinear counterparts
and _breakpoint regions_ are the remaining intervals.  _Colinear regions_ 
(or _chains_) are the union of _colinear alignments_ and _bridge regions_.

As Bioconductor's `gaps()` function returns also the unaligned sequences between
the start/end of chromosome and the first/last block, we use the `?cleanGaps`
function that removes them before returning the object.
   
```{r clean_gaps}
isol <- gb[gb %in% coa]
coli <- gb[!gb %in% coa]
bri  <- bridgeRegions(gb)
brk  <- cleanGaps(coa)
brk_q <- cleanGaps(coa$query)
```

```{r plot_widths, dev = c('svg', 'png')}
# Need to wrap in a function to handle empty GRanges objects...
width2df <- function(what, gr) {
  if (length(gr) == 0) {
    data.frame(what = what, width = 0)
  } else { 
    data.frame(what = what, width = width(gr))
  }
}

rbind(
  width2df(what = "isol_aln", gr = isol),
  width2df(what = "breakpoint_regions",   gr = brk),
  width2df(what = "colinear_aln", gr = coli),
  width2df(what = "colinear_region", gr = coa),
  width2df(what = "bridge", gr = bri)
) |> ggplot() +
  aes(width) +
  geom_histogram() +
  scale_x_log10() +
  facet_wrap(~what, ncol = 1, scales = "free_y")
```

Inversions
----------

```{r study_inversions}
coa <- flagInversions(coa)
sum(coa$inv)
inv <- showInversions(coa)
head(inv, 11)
if (sum(coa$inv) > 10) {
  # Histogram of the widths
  ggplot(data.frame(width = width(filterInversions(coa)))) +
    aes(width) +
    geom_histogram() +
    scale_x_log10()
}
```

Translocations
--------------

Patterns that can be described as translocations in the target genome.

```{r study_translocations}
coa <- flagTranslocations(coa)
sum(coa$tra)
tra <- showTranslocations(coa)
head(tra, 11)

if (sum(coa$tra) > 10) {
  # Histogram of the widths
  ggplot(data.frame(width = width(filterTranslocations(coa)))) +
    aes(width) +
    geom_histogram() +
    scale_x_log10()
}
```


Calculate numbers and prepare them for export in a YAML file
------------------------------------------------------------

```{r count_features}
L50width <- function(gb) weighted.mean(width(gb), as.numeric(width(gb))) # as.num to avoid integer overflow
summaryWidth <- function(gb, pasteToNames=NULL) {
  if(length(gb) == 0) return(NULL)
  s <- summary(width(gb))
  names(s) <- c("Min", "Q1", "Median", "Mean", "Q3", "Max")
  s["L50"]     <- L50width(gb)
  s["Total"]   <- sum(width(gb))
  s["N"]       <- length(gb)
  s <- as.list(s)
  names(s) <- paste0(pasteToNames, names(s))
  s
}
  
report <- list() |>
  c(aligned_length_total = sum(gb$aLength)) |>
  c(matching_length_total = sum(gb$matches)) |>
  c(percent_identity = 100 * sum(gb$matches) / sum(gb$aLength)) |>
  c(summaryWidth(gb,         "aligned_target_"))      |>
  c(summaryWidth(gb$query,   "aligned_query_"))       |>
  c(summaryWidth(coa,        "chain_target_"))        |>
  c(summaryWidth(coa$query,  "chain_query_"))         |>
  c(summaryWidth(coli,       "collinear_target_"))    |>
  c(summaryWidth(coli$query, "collinear_query_"))     |>
  c(summaryWidth(isol,       "isolated_target_"))     |>
  c(summaryWidth(isol$query,  "isolated_query_"))     |>
  c(summaryWidth(bri,        "bridge_target_"))       |>
  c(summaryWidth(bri$query,  "bridge_query_"))        |>
  c(summaryWidth(brk,        "break_target_"))        |>
  c(summaryWidth(brk_q,      "break_query_"))         |>
  c(summaryWidth(inv,        "inverted_target_"))     |>
  c(summaryWidth(inv$query,  "inverted_query_"))      |>
  c(summaryWidth(tra,        "translocated_target_")) |>
  c(summaryWidth(tra$query,  "translocated_query_"))  |>
  c(guessed_target_length = sum(guessSeqLengths(gb))) |>
  c(guessed_query_length =  sum(guessSeqLengths(gb$query))) |>
  c(index_synteny_target = synteny_index(gb)) |>
  c(index_synteny_query  = synteny_index(swap(gb))) |>
  c(index_correlation_target = correlation_index(gb)) |>
  c(index_correlation_query = correlation_index(swap(gb))) |>
  c(index_GOCvicinity4_target = GOC(gb, vicinity = 4)) |> # Default as of today.  Does not make much sense on nucleotide sequences?
  c(index_GOCvicinity4_query = GOC(swap(gb), vicinity = 4)) |> # Default as of today.  Does not make much sense on nucleotide sequences?
  c(index_strandRand_target = strand_randomisation_index(gb)) |>
  c(index_strandRand_query = strand_randomisation_index(swap(gb)))
```

Export the results to a YAML file.

```{r export_results}
yaml <- yaml::as.yaml(report)
yaml::write_yaml(yaml, paste0(params$prefix, ".yaml"))
cat(yaml)
```
