---
title: "Count features"
author: "Charles Plessy"
date: "02/07/2023"
output: 
  html_document: 
    keep_md: yes
params:
  mafFile: "~/FromDeigo/Fungi_Ncra/Podospora_comata.07.postmasked.maf.gz"
  prefix: "Fungi_Ncra"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(progress = TRUE, verbose = TRUE, root.dir = system2("pwd", stdout = TRUE))
```

```{r load_libraries}
library("GenomicBreaks") |> suppressPackageStartupMessages()
library("ggplot2") |> suppressPackageStartupMessages()
```

How to use this Rmarkdown template:

It is essential to set `R_LIBS_USER` to an empty value, otherwise `R` will
attempt to load packages from the user's library, which were compiled in a
different environment than the GenomicBreaks Singularity image.

Example command

```
R_LIBS_USER='' R -e 'rmarkdown::render("thisTemplate.Rmd", output_file = "./outFile.html", params = list(axtFile = "/path/do/dir/with/alignment/files"))'
```

Load data
---------

```{r load_data}
# Display parameters
params

# Load the alignment in a GBreaks object
gb <-load_genomic_breaks(params$mafFile)
```

Coalesce contigs and study unaligned regions
--------------------------------------------

```{r flag_genomic_breaks}
gb <- gb |>
  flagColinearAlignments() |>
  flagTranslocations() |>
  flagInversions()
sapply(mcols(gb)[,c("colinear", "tra", "inv")], sum)
```

```{r coalesce_contigs}
coa <- coalesce_contigs(gb)
```

We flag the alignments again after discarding the shortest regions.  This
allows the short colinear regions to consolidate first.  Thus, we only remove
the short alignments that interrupt the colinearity of longer ones.

### Extract information

Let's call the intervals between two alignment parts “_Unaligned_” sequences.
We need a function that returns only them.  Bioconductor's `gaps()` function
will return also the unaligned sequences between the start/end of chromosome
and the first/last block.  The `cleanGaps` function below removes them before
returning the object.
   
```{r clean_gaps}
gb_unal  <- cleanGaps(gb)
coa_unal <- cleanGaps(coa)
```

```{r plot_widths, dev = c('svg', 'png')}
# To handle cases where everything is collapsed
coa_unal__ <-
  if(length(coa_unal) == 0) {
    IRanges(start = 1, width = 0)
  } else {
    coa_unal
  }

# Need to wrap in a function to handle empty GRanges objects...
width2df <- function(what, gr) {
  if (length(gr) == 0) return (NULL)
  data.frame(what = what, width = width(gr))
}

df <- rbind(
  width2df(what = "aligned",     gr = gb),
  width2df(what = "unaligned",   gr = gb_unal),
  width2df(what = "collapsed",   gr = coa),
  width2df(what = "uncollapsed", gr = coa_unal__)
)

ggplot(df) +
  aes(width) +
  geom_histogram() +
  scale_x_log10() +
  facet_wrap(~what, nrow = 2)
```

Inversions
----------

```{r study_inversions}
coa <- flagInversions(coa)
sum(coa$inv)
showInversions(coa) |> head(11)
if (sum(coa$inv) > 10) {
  # Histogram of the widths
  ggplot(data.frame(width = width(coa[coa$inv]))) +
    aes(width) +
    geom_histogram() +
    scale_x_log10()
  
  # Why are the inversions overwhelmingly on the plus strand ?
  ggplot(data.frame(strand = strand(coa[coa$inv]))) +
    aes(strand) +
    geom_bar()
}
```

Translocations
--------------

Patterns that can be described as translocations in the target genome.

```{r study_translocations}
coa <- flagTranslocations(coa)
sum(coa$tra)
traPos <- NULL
if (sum(coa$tra) > 10) {
  traPos <- which(coa$tra) + 1
  insContext <- c(traPos -1 , traPos, traPos + 1) |> unique() |> sort()
  coa[traPos]
  coa[insContext] |> head(11)
  
  # Histogram of the widths
  ggplot(data.frame(width = width(coa[traPos]))) +
    aes(width) +
    geom_histogram() +
    scale_x_log10()
  
  # Why are the inversions overwhelmingly on the plus strand ?
  ggplot(data.frame(strand = strand(coa[traPos]))) +
    aes(strand) +
    geom_bar()
}
```


Calculate numbers and prepare them for export in a YAML file
------------------------------------------------------------

```{r count_features}
report <- list()

report[["aligned_length_total"]]  <- sum(gb$aLength)
report[["aligned_target_total"]]  <- sum(width(gb))
report[["aligned_query_total"]]   <- sum(width(gb$query))
report[["aligned_ranges_number"]] <- length(gb)

report[["colinear_target_total"]] <- sum(width(coa))
report[["colinear_query_total"]]  <- sum(width(coa$query))
report[["colinear_ranges_number"]] <- length(coa)

report[["percent_similarity"]] <- 1 - sum(gb$matches) / sum(gb$aLength)

report[["number_of_inversions"]]       <- sum(coa$inv)
report[["number_of_transpositionsl"]]  <- sum(coa$tra)

report[["synteny_index"]]              <- synteny_index(gb)
report[["correlation_index"]]          <- correlation_index(gb)
report[["GOC_vicinity_4"]]             <- GOC(gb, vicinity = 4) # Default as of today
report[["strand_randomisation_index"]] <- strand_randomisation_index(gb)
```

Export the results to a YAML file.

```{r export_results}
yaml <- yaml::as.yaml(report)
yaml::write_yaml(yaml, paste0(params$prefix, ".yaml"))
cat(yaml)
```
